"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[642],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>b});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,b=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return n?a.createElement(b,o(o({ref:t},p),{},{components:n})):a.createElement(b,o({ref:t},p))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},42083:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const i={sidebar_position:3},o="Migrations",l={unversionedId:"Migrations",id:"Migrations",title:"Migrations",description:"Writing Migrations",source:"@site/docs/Migrations.md",sourceDirName:".",slug:"/Migrations",permalink:"/lapis/docs/Migrations",draft:!1,editUrl:"https://github.com/nezuo/lapis/edit/master/docs/Migrations.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"defaultSidebar",previous:{title:"Example Usage",permalink:"/lapis/docs/Example"},next:{title:"Handling Developer Products",permalink:"/lapis/docs/DeveloperProduct"}},s={},c=[{value:"Writing Migrations",id:"writing-migrations",level:2},{value:"Backwards Compatibility",id:"backwards-compatibility",level:2},{value:"How to fix mistakes in backwards compatibilty?",id:"how-to-fix-mistakes-in-backwards-compatibilty",level:3}],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"migrations"},"Migrations"),(0,r.kt)("h2",{id:"writing-migrations"},"Writing Migrations"),(0,r.kt)("p",null,"Migrations allow you to update the structure of your data over time. You can add new keys, remove ones you no longer need, or change the way you store something."),(0,r.kt)("p",null,"Here is an example of a few migrations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local MIGRATIONS = {\n    -- Migrate from version 0 to 1.\n    function(old)\n        return Dictionary.merge(old, {\n            coins = 0, -- Add a key called coins to the data.\n        })\n    end,\n    -- Migrate from version 1 to 2.\n    function(old)\n        -- We no longer need the playTime key, so we remove it.\n        -- Note: Migrations can update the data mutably but you still need to return the value.\n        old.playTime = nil\n\n        return old\n    end,\n}\n\nlocal collection = Lapis.createCollection("collection", {\n    migrations = MIGRATIONS,\n    validate = validate,\n    defaultData = DEFAULT_DATA,\n})\n')),(0,r.kt)("h2",{id:"backwards-compatibility"},"Backwards Compatibility"),(0,r.kt)("p",null,"If you release an update that includes a migration, a player might join a new server, leave, and then join an old server.\nThis would cause the player's document to fail to load on the old server since the document's version would be ahead of the old server's version."),(0,r.kt)("p",null,"To solve this problem, you have two options:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Use Roblox's ",(0,r.kt)("inlineCode",{parentName:"li"},"Migrate To Latest Update")," feature to ensure all servers are up-to-date."),(0,r.kt)("li",{parentName:"ol"},"Make your migrations backwards compatible.")),(0,r.kt)("p",null,"Here's an example of how to make migrations backwards compatible:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function v1()\n    -- v1 removes a key which causes an error on servers with version 0.\n    old.playTime = nil\n    return old\nend\n\nlocal function v2()\n    -- v2 adds a new value to the player's data which won't result in an error on servers with version 1.\n    old.items = {}\n    return old\nend\n\nlocal function v3()\n    -- v3 removes a key which causes an error on servers with version 0, 1, or 2.\n    old.coins = nil\n    return old\nend\n\nlocal MIGRATIONS = {\n    {\n        migrate = v1,\n        backwardsCompatible = false, -- Version 1 isn't backwards compatible with version 0.\n    },\n    {\n        migrate = v2,\n        backwardsCompatible = true, -- Version 2 is backwards compatible with version 1.\n    },\n    v3, -- Migrations aren't backwards compatible by default.\n}\n")),(0,r.kt)("p",null,"A migration is backwards compatible with the previous version if it can be safely loaded on an old server without resulting in bugs, errors, or incorrect behavior."),(0,r.kt)("p",null,"Generally, additive changes are backwards compatible, while removals are not. It's up to you to determine when a change is backwards compatible."),(0,r.kt)("p",null,"Backward compatibility is transitive, so for example, if ",(0,r.kt)("inlineCode",{parentName:"p"},"v2")," is backwards compatible with ",(0,r.kt)("inlineCode",{parentName:"p"},"v1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"v3")," is backwards compatible with ",(0,r.kt)("inlineCode",{parentName:"p"},"v2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"v3")," is also backwards compatible with ",(0,r.kt)("inlineCode",{parentName:"p"},"v1"),"."),(0,r.kt)("p",null,"Note that a migration won't be backwards compatible if it fails to pass the previous version's validation. If you intend to\nuse backwards compatibilty, you should use functions like ",(0,r.kt)("inlineCode",{parentName:"p"},"t.interface")," over ",(0,r.kt)("inlineCode",{parentName:"p"},"t.strictInterface"),"."),(0,r.kt)("h3",{id:"how-to-fix-mistakes-in-backwards-compatibilty"},"How to fix mistakes in backwards compatibilty?"),(0,r.kt)("p",null,"If you mistakenly mark a change as backwards compatible when it isn't, you will need to use ",(0,r.kt)("inlineCode",{parentName:"p"},"Migrate To Latest Update")," to correct it. Therefore, be careful not to mark ",(0,r.kt)("inlineCode",{parentName:"p"},"backwardsCompatible")," incorrectly!"))}u.isMDXComponent=!0}}]);