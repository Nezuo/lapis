[{"title":"Collection","type":0,"sectionRef":"#","url":"/lapis/api/Collection","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Collection","url":"/lapis/api/Collection#functions","content":" "},{"title":"load​","type":1,"pageTitle":"Collection","url":"/lapis/api/Collection#load","content":"&lt;/&gt; Collection:load( key: string, defaultUserIds: {number}? ) → Promise&lt;Document&gt; Loads the document with key, migrates it, and session locks it. If specified, the document's DataStoreKeyInfo:GetUserIds() will be set to defaultUserIds if the document has never been loaded. "},{"title":"Introduction","type":0,"sectionRef":"#","url":"/lapis/docs/intro","content":"","keywords":""},{"title":"Features​","type":1,"pageTitle":"Introduction","url":"/lapis/docs/intro#features","content":"Session Locking - Documents can only be accessed from one server at a time. This prevents some bugs and duping methods.Validation - Ensure your data is correct before saving it.Migrations - Update the structure of your data over time.Retries - Failed DataStore requests will be retried.Throttling - DataStore requests will never exceed their budget and throw an error.Promise-based API - Promises are used instead of yielding.Immutability - Documents must be updated immutably.Save Batching - Pending Document:save() and Document:close() calls are combined into one DataStore request when possible.Auto Save - Documents are automatically saved every 5 minutes.BindToClose - All documents are automatically closed when the game shuts down. "},{"title":"Writing Migrations","type":0,"sectionRef":"#","url":"/lapis/docs/Migrations","content":"Writing Migrations Migrations allow you to update the structure of your data over time. You can add new keys, remove ones you no longer need, or change the way you store something. Here is an example of a few migrations: local MIGRATIONS = { -- Migrate from version 1 to 2. function(old) return Dictionary.merge(old, { coins = 0, -- Add a key called coins to the data. }) end, -- Migrate from version 2 to 3. function(old) -- We no longer need the playTime key, so we remove it. return Dictionary.removeKey(old, &quot;playTime&quot;) end, } local collection = Lapis.createCollection(&quot;collection&quot;, { migrations = MIGRATIONS, validate = validate, defaultData = DEFAULT_DATA, }) ","keywords":""},{"title":"Example Usage","type":0,"sectionRef":"#","url":"/lapis/docs/Example","content":"Example Usage The following code is an example of how you would load and close player data: local DEFAULT_DATA = { coins = 100 } local collection = Lapis.createCollection(&quot;PlayerData&quot;, { defaultData = DEFAULT_DATA, -- You can use t by osyrisrblx to type check your data at runtime. validate = t.strictInterface({ coins = t.integer }), }) local documents = {} local function onPlayerAdded(player: Player) -- The second argument associates the document with the player's UserId which is useful -- for GDPR compliance. collection :load(`Player{player.UserId}`, { player.UserId }) :andThen(function(document) if player.Parent == nil then -- The player might have left before the document finished loading. -- The document needs to be closed because PlayerRemoving won't fire at this point. document:close():catch(warn) return end documents[player] = document end) :catch(function(message) warn(`Player {player.Name}'s data failed to load: {message}`) -- Optionally, you can kick the player when their data fails to load: player:Kick(&quot;Data failed to load.&quot;) end) end local function onPlayerRemoving(player: Player) local document = documents[player] -- The document won't be added to the dictionary if PlayerRemoving fires bofore it finishes loading. if document ~= nil then documents[player] = nil document:close():catch(warn) end end Players.PlayerAdded:Connect(onPlayerAdded) Players.PlayerRemoving:Connect(onPlayerRemoving) for _, player in Players:GetPlayers() do onPlayerAdded(player) end info You do not need to handle game:BindToClose or auto saving. Lapis automatically does both of those.","keywords":""},{"title":"Lapis","type":0,"sectionRef":"#","url":"/lapis/api/Lapis","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Lapis","url":"/lapis/api/Lapis#functions","content":" "},{"title":"setConfig​","type":1,"pageTitle":"Lapis","url":"/lapis/api/Lapis#setConfig","content":"&lt;/&gt; Lapis.setConfig(partialConfig: PartialLapisConfig) → () "},{"title":"Types","type":1,"pageTitle":"Lapis","url":"/lapis/api/Lapis##","content":""},{"title":"​","type":1,"pageTitle":"Lapis","url":"/lapis/api/Lapis#PartialLapisConfig","content":"interface PartialLapisConfig { saveAttempts: number?-- Max save/close retry attempts loadAttempts: number?-- Max load retry attempts loadRetryDelay: number?-- Seconds between load attempts showRetryWarnings: boolean?-- Show warning on retry dataStoreService: (DataStoreService | table)?-- Useful for mocking DataStoreService, especially in a local place }  Lapis.setConfig({ saveAttempts = 10, showRetryWarnings = false, }) -- The default config values: { saveAttempts = 5, loadAttempts = 20, loadRetryDelay = 1, showRetryWarnings = true, dataStoreService = DataStoreService, }   "},{"title":"createCollection​","type":1,"pageTitle":"Lapis","url":"/lapis/api/Lapis#createCollection","content":"&lt;/&gt; Lapis.createCollection( name: string, options: CollectionOptions ) → Collection "},{"title":"Types","type":1,"pageTitle":"Lapis","url":"/lapis/api/Lapis##","content":""},{"title":"​","type":1,"pageTitle":"Lapis","url":"/lapis/api/Lapis#CollectionOptions","content":"interface CollectionOptions { validate: (any) → true | ( false, string )-- Takes a document's data and returns true on success or false and an error on fail. defaultData: any migrations: {(any) → any}?-- Migrations take old data and return new data. Order is first to last. }  Creates a Collection. "},{"title":"Document","type":0,"sectionRef":"#","url":"/lapis/api/Document","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#functions","content":" "},{"title":"read​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#read","content":"&lt;/&gt; Document:read() → any Returns the document's data.  "},{"title":"write​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#write","content":"&lt;/&gt; Document:write(data: any) → () Writes the document's data. warning Throws an error if the document was closed or if the data is invalid.  "},{"title":"addUserId​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#addUserId","content":"&lt;/&gt; Document:addUserId(userId: number) → () Adds a user id to the document's DataStoreKeyInfo:GetUserIds(). The change won't apply until the document is saved or closed. If the user id is already associated with the document the method won't do anything.  "},{"title":"removeUserId​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#removeUserId","content":"&lt;/&gt; Document:removeUserId(userId: number) → () Removes a user id from the document's DataStoreKeyInfo:GetUserIds(). The change won't apply until the document is saved or closed. If the user id is not associated with the document the method won't do anything.  "},{"title":"save​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#save","content":"&lt;/&gt; Document:save() → Promise&lt;()&gt; Saves the document's data. If the save is throttled and you call it multiple times, it will save only once with the latest data. warning Throws an error if the document was closed. warning If the beforeSave callback errors, the returned promise will reject and the data will not be saved.  "},{"title":"close​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#close","content":"&lt;/&gt; Document:close() → Promise&lt;()&gt; Saves the document and removes the session lock. The document is unusable after calling. If a save is currently in progress it will close the document instead. If called again, it will return the promise from the original call. warning If the beforeSave or beforeClose callbacks error, the returned promise will reject and the data will not be saved.  "},{"title":"beforeSave​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#beforeSave","content":"&lt;/&gt; Document:beforeSave(callback: () → ()) → () Sets a callback that is run inside document:save and document:close before it saves. The document can be read and written to in the callback. The callback will run before the beforeClose callback inside of document:close. warning Throws an error if it was called previously.  "},{"title":"beforeClose​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#beforeClose","content":"&lt;/&gt; Document:beforeClose(callback: () → ()) → () Sets a callback that is run inside document:close before it saves. The document can be read and written to in the callback. warning Throws an error if it was called previously. "},{"title":"Handling Developer Products","type":0,"sectionRef":"#","url":"/lapis/docs/DeveloperProduct","content":"Handling Developer Products The following code is an example of how you would handle players purchasing developer products: local DEFAULT_DATA = { coins = 100, recentPurchases = {} } local RECENT_PURCHASES_LIMIT = 100 local PRODUCTS = { [12345] = function(oldData) -- Product callbacks return a new version of the data. return Sift.Dictionary.merge(oldData, { coins = oldData.coins + 100, }) end, } local collection = Lapis.createCollection(&quot;PlayerData&quot;, { defaultData = DEFAULT_DATA, validate = t.strictInterface({ coins = t.integer, recentPurchases = t.array(t.string) }), }) local documents = {} local function onPlayerAdded(player: Player) collection :load(`Player{player.UserId}`, { player.UserId }) :andThen(function(document) if player.Parent == nil then document:close():catch(warn) return end documents[player] = document end) :catch(function(message) warn(`Player {player.Name}'s data failed to load: {message}`) player:Kick(&quot;Data failed to load.&quot;) end) end local function onPlayerRemoving(player: Player) local document = documents[player] if document ~= nil then documents[player] = nil document:close():catch(warn) end end local function processReceipt(receiptInfo): Enum.ProductPurchaseDecision local player = Players:GetPlayerByUserId(receiptInfo.PlayerId) if player == nil then return Enum.ProductPurchaseDecision.NotProcessedYet end while documents[player] == nil and player.Parent ~= nil do -- Wait until the document loads or the player leaves. task.wait() end local document = documents[player] if document == nil then return Enum.ProductPurchaseDecision.NotProcessedYet end local data = document:read() if table.find(data.recentPurchases, receiptInfo.PurchaseId) then -- The purchase has been added to the player's data, but it might not have saved yet. local saveOk = document:save():await() if saveOk then return Enum.ProductPurchaseDecision.PurchaseGranted else return Enum.ProductPurchaseDecision.NotProcessedYet end end -- The product callback must not yield. Otherwise, it can return outdated data and overwrite new changes. local productOk, dataWithProduct = pcall(PRODUCTS[receiptInfo.ProductId], data) if not productOk then return Enum.ProductPurchaseDecision.NotProcessedYet end local newRecentPurchases = Sift.Array.push(data.recentPurchases, receiptInfo.PurchaseId) if #newRecentPurchases &gt; RECENT_PURCHASES_LIMIT then newRecentPurchases = Sift.Array.shift(newRecentPurchases, #newRecentPurchases - RECENT_PURCHASES_LIMIT) end document:write(Sift.Dictionary.merge(dataWithProduct, { recentPurchases = newRecentPurchases, })) local saveOk = document:save():await() if not saveOk then return Enum.ProductPurchaseDecision.NotProcessedYet end return Enum.ProductPurchaseDecision.PurchaseGranted end -- The ProcessReceipt callback must be set before the Players.PlayerAdded signal is fired, otherwise the player's -- existing receipts won't be processed when they join. MarketplaceService.ProcessReceipt = processReceipt Players.PlayerAdded:Connect(onPlayerAdded) Players.PlayerRemoving:Connect(onPlayerRemoving) for _, player in Players:GetPlayers() do onPlayerAdded(player) end ","keywords":""}]