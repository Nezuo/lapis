[{"title":"Introduction","type":0,"sectionRef":"#","url":"/lapis/docs/intro","content":"","keywords":""},{"title":"Features​","type":1,"pageTitle":"Introduction","url":"/lapis/docs/intro#features","content":"Session Locking - Documents can only be accessed from one server at a time. This prevents some bugs and duping methods.Validation - Ensure your data is correct before saving it.Migrations - Update the structure of your data over time.Retries - Failed DataStore requests will be retried.Throttling - DataStore requests will never exceed their budget and throw an error.Promise-based API - Promises are used instead of yielding.Immutability - By default, documents are deep frozen must be updated immutably. This can be disabled.Save Batching - Pending Document:save() and Document:close() calls are combined into one DataStore request when possible.Auto Save - Documents are automatically saved every 5 minutes.BindToClose - All documents are automatically closed when the game shuts down. "},{"title":"Collection","type":0,"sectionRef":"#","url":"/lapis/api/Collection","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Collection","url":"/lapis/api/Collection#functions","content":" "},{"title":"load​","type":1,"pageTitle":"Collection","url":"/lapis/api/Collection#load","content":"&lt;/&gt; Collection:load( key: string, defaultUserIds: {number}? ) → Promise&lt;Document&gt; Loads the document with key, migrates it, and session locks it. If specified, the document's DataStoreKeyInfo:GetUserIds() will be set to defaultUserIds if the document has never been loaded. "},{"title":"Migrations","type":0,"sectionRef":"#","url":"/lapis/docs/Migrations","content":"","keywords":""},{"title":"Writing Migrations​","type":1,"pageTitle":"Migrations","url":"/lapis/docs/Migrations#writing-migrations","content":"Migrations allow you to update the structure of your data over time. You can add new keys, remove ones you no longer need, or change the way you store something. Here is an example of a few migrations: local MIGRATIONS = { -- Migrate from version 0 to 1. function(old) return Dictionary.merge(old, { coins = 0, -- Add a key called coins to the data. }) end, -- Migrate from version 1 to 2. function(old) -- We no longer need the playTime key, so we remove it. -- Note: Migrations can update the data mutably but you still need to return the value. old.playTime = nil return old end, } local collection = Lapis.createCollection(&quot;collection&quot;, { migrations = MIGRATIONS, validate = validate, defaultData = DEFAULT_DATA, })  "},{"title":"Backwards Compatibility​","type":1,"pageTitle":"Migrations","url":"/lapis/docs/Migrations#backwards-compatibility","content":"If you release an update that includes a migration, a player might join a new server, leave, and then join an old server. This would cause the player's document to fail to load on the old server since the document's version would be ahead of the old server's version. To solve this problem, you have two options: Use Roblox's Migrate To Latest Update feature to ensure all servers are up-to-date.Make your migrations backwards compatible. Here's an example of how to make migrations backwards compatible: local function v1() -- v1 removes a key which causes an error on servers with version 0. old.playTime = nil return old end local function v2() -- v2 adds a new value to the player's data which won't result in an error on servers with version 1. old.items = {} return old end local function v3() -- v3 removes a key which causes an error on servers with version 0, 1, or 2. old.coins = nil return old end local MIGRATIONS = { { migrate = v1, backwardsCompatible = false, -- Version 1 isn't backwards compatible with version 0. }, { migrate = v2, backwardsCompatible = true, -- Version 2 is backwards compatible with version 1. }, v3, -- Migrations aren't backwards compatible by default. }  A migration is backwards compatible with the previous version if it can be safely loaded on an old server without resulting in bugs, errors, or incorrect behavior. Generally, additive changes are backwards compatible, while removals are not. It's up to you to determine when a change is backwards compatible. Backward compatibility is transitive, so for example, if v2 is backwards compatible with v1 and v3 is backwards compatible with v2, v3 is also backwards compatible with v1. Note that a migration won't be backwards compatible if it fails to pass the previous version's validation. If you intend to use backwards compatibilty, you should use functions like t.interface over t.strictInterface. "},{"title":"How to fix mistakes in backwards compatibilty?​","type":1,"pageTitle":"Migrations","url":"/lapis/docs/Migrations#how-to-fix-mistakes-in-backwards-compatibilty","content":"If you mistakenly mark a change as backwards compatible when it isn't, you will need to use Migrate To Latest Update to correct it. Therefore, be careful not to mark backwardsCompatible incorrectly! "},{"title":"Lapis","type":0,"sectionRef":"#","url":"/lapis/api/Lapis","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Lapis","url":"/lapis/api/Lapis#types","content":" "},{"title":"Migration​","type":1,"pageTitle":"Lapis","url":"/lapis/api/Lapis#Migration","content":"&lt;/&gt; type Migration = (any) → any | { backwardsCompatible: boolean?, migrate: (any) → any }   "},{"title":"CollectionOptions<T>​","type":1,"pageTitle":"Lapis","url":"/lapis/api/Lapis#CollectionOptions<T>","content":"&lt;/&gt; interface CollectionOptions&lt;T&gt; { validate: ((any) → true | ( false, string ))?-- Takes a document's data and returns true on success or false and an error on fail. defaultData: T | (key: string) → T-- If set to a function, it's called when a new document is created and is passed the key of the document. freezeData: boolean?-- If true, data will be deep frozen and can only be updated immutably by calling Document:write. Default: true migrations: {Migration}?-- Migrations take old data and return new data. Order is first to last. For more information, see: Migrations. }  "},{"title":"Functions​","type":1,"pageTitle":"Lapis","url":"/lapis/api/Lapis#functions","content":" "},{"title":"setConfig​","type":1,"pageTitle":"Lapis","url":"/lapis/api/Lapis#setConfig","content":"&lt;/&gt; Lapis.setConfig(partialConfig: PartialLapisConfig) → () "},{"title":"Types","type":1,"pageTitle":"Lapis","url":"/lapis/api/Lapis##","content":""},{"title":"​","type":1,"pageTitle":"Lapis","url":"/lapis/api/Lapis#PartialLapisConfig","content":"interface PartialLapisConfig { saveAttempts: number?-- Max save/close retry attempts loadAttempts: number?-- Max load retry attempts loadRetryDelay: number?-- Seconds between load attempts showRetryWarnings: boolean?-- Show warning on retry dataStoreService: (DataStoreService | table)?-- Useful for mocking DataStoreService, especially in a local place }  Lapis.setConfig({ saveAttempts = 10, showRetryWarnings = false, }) -- The default config values: { saveAttempts = 5, loadAttempts = 20, loadRetryDelay = 1, showRetryWarnings = true, dataStoreService = DataStoreService, }   "},{"title":"createCollection​","type":1,"pageTitle":"Lapis","url":"/lapis/api/Lapis#createCollection","content":"&lt;/&gt; Lapis.createCollection( name: string, options: CollectionOptions ) → Collection Creates a Collection. "},{"title":"Example Usage","type":0,"sectionRef":"#","url":"/lapis/docs/Example","content":"Example Usage The following code is an example of how you would load and close player data: local DEFAULT_DATA = { coins = 100 } local collection = Lapis.createCollection(&quot;PlayerData&quot;, { defaultData = DEFAULT_DATA, -- You can use t by osyrisrblx to type check your data at runtime. validate = t.strictInterface({ coins = t.integer }), }) local documents = {} local function onPlayerAdded(player: Player) -- The second argument associates the document with the player's UserId which is useful -- for GDPR compliance. collection :load(`Player{player.UserId}`, { player.UserId }) :andThen(function(document) if player.Parent == nil then -- The player might have left before the document finished loading. -- The document needs to be closed because PlayerRemoving won't fire at this point. document:close():catch(warn) return end documents[player] = document end) :catch(function(message) warn(`Player {player.Name}'s data failed to load: {message}`) -- Optionally, you can kick the player when their data fails to load: player:Kick(&quot;Data failed to load.&quot;) end) end local function onPlayerRemoving(player: Player) local document = documents[player] -- The document won't be added to the dictionary if PlayerRemoving fires bofore it finishes loading. if document ~= nil then documents[player] = nil document:close():catch(warn) end end Players.PlayerAdded:Connect(onPlayerAdded) Players.PlayerRemoving:Connect(onPlayerRemoving) for _, player in Players:GetPlayers() do onPlayerAdded(player) end info You do not need to handle game:BindToClose or auto saving. Lapis automatically does both of those.","keywords":""},{"title":"Document","type":0,"sectionRef":"#","url":"/lapis/api/Document","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#functions","content":" "},{"title":"read​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#read","content":"&lt;/&gt; Document:read() → any Returns the document's data.  "},{"title":"write​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#write","content":"&lt;/&gt; Document:write(data: any) → () Writes the document's data. If CollectionOptions.freezeData is true, data will be deep frozen. warning Throws an error if the document was closed or if the data is invalid.  "},{"title":"addUserId​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#addUserId","content":"&lt;/&gt; Document:addUserId(userId: number) → () Adds a user id to the document's DataStoreKeyInfo:GetUserIds(). The change won't apply until the document is saved or closed. If the user id is already associated with the document the method won't do anything.  "},{"title":"removeUserId​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#removeUserId","content":"&lt;/&gt; Document:removeUserId(userId: number) → () Removes a user id from the document's DataStoreKeyInfo:GetUserIds(). The change won't apply until the document is saved or closed. If the user id is not associated with the document the method won't do anything.  "},{"title":"keyInfo​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#keyInfo","content":"&lt;/&gt; Document:keyInfo() → DataStoreKeyInfo  Returns the last updated DataStoreKeyInfo returned from loading, saving, or closing the document.  "},{"title":"save​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#save","content":"&lt;/&gt; Document:save() → Promise&lt;()&gt; Saves the document's data. If the save is throttled and you call it multiple times, it will save only once with the latest data. warning Throws an error if the document was closed. warning If the beforeSave callback errors, the returned promise will reject and the data will not be saved.  "},{"title":"close​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#close","content":"&lt;/&gt; Document:close() → Promise&lt;()&gt; Saves the document and removes the session lock. The document is unusable after calling. If a save is currently in progress it will close the document instead. If called again, it will return the promise from the original call. warning If the beforeSave or beforeClose callbacks error, the returned promise will reject and the data will not be saved.  "},{"title":"beforeSave​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#beforeSave","content":"&lt;/&gt; Document:beforeSave(callback: () → ()) → () Sets a callback that is run inside document:save and document:close before it saves. The document can be read and written to in the callback. The callback will run before the beforeClose callback inside of document:close. warning Throws an error if it was called previously.  "},{"title":"beforeClose​","type":1,"pageTitle":"Document","url":"/lapis/api/Document#beforeClose","content":"&lt;/&gt; Document:beforeClose(callback: () → ()) → () Sets a callback that is run inside document:close before it saves. The document can be read and written to in the callback. warning Throws an error if it was called previously. "},{"title":"Handling Developer Products","type":0,"sectionRef":"#","url":"/lapis/docs/DeveloperProduct","content":"Handling Developer Products The following code is an example of how you would handle players purchasing developer products: local DEFAULT_DATA = { coins = 100, recentPurchases = {} } local RECENT_PURCHASES_LIMIT = 100 local PRODUCTS = { [12345] = function(oldData) -- Product callbacks return a new version of the data. return Sift.Dictionary.merge(oldData, { coins = oldData.coins + 100, }) end, } local collection = Lapis.createCollection(&quot;PlayerData&quot;, { defaultData = DEFAULT_DATA, validate = t.strictInterface({ coins = t.integer, recentPurchases = t.array(t.string) }), }) local documents = {} local function onPlayerAdded(player: Player) collection :load(`Player{player.UserId}`, { player.UserId }) :andThen(function(document) if player.Parent == nil then document:close():catch(warn) return end documents[player] = document end) :catch(function(message) warn(`Player {player.Name}'s data failed to load: {message}`) player:Kick(&quot;Data failed to load.&quot;) end) end local function onPlayerRemoving(player: Player) local document = documents[player] if document ~= nil then documents[player] = nil document:close():catch(warn) end end local function processReceipt(receiptInfo): Enum.ProductPurchaseDecision local player = Players:GetPlayerByUserId(receiptInfo.PlayerId) if player == nil then return Enum.ProductPurchaseDecision.NotProcessedYet end while documents[player] == nil and player.Parent ~= nil do -- Wait until the document loads or the player leaves. task.wait() end local document = documents[player] if document == nil then return Enum.ProductPurchaseDecision.NotProcessedYet end local data = document:read() if table.find(data.recentPurchases, receiptInfo.PurchaseId) then -- The purchase has been added to the player's data, but it might not have saved yet. local saveOk = document:save():await() if saveOk then return Enum.ProductPurchaseDecision.PurchaseGranted else return Enum.ProductPurchaseDecision.NotProcessedYet end end -- The product callback must not yield. Otherwise, it can return outdated data and overwrite new changes. local productOk, dataWithProduct = pcall(PRODUCTS[receiptInfo.ProductId], data) if not productOk then return Enum.ProductPurchaseDecision.NotProcessedYet end local newRecentPurchases = Sift.Array.push(data.recentPurchases, receiptInfo.PurchaseId) if #newRecentPurchases &gt; RECENT_PURCHASES_LIMIT then newRecentPurchases = Sift.Array.shift(newRecentPurchases, #newRecentPurchases - RECENT_PURCHASES_LIMIT) end document:write(Sift.Dictionary.merge(dataWithProduct, { recentPurchases = newRecentPurchases, })) local saveOk = document:save():await() if not saveOk then return Enum.ProductPurchaseDecision.NotProcessedYet end return Enum.ProductPurchaseDecision.PurchaseGranted end -- The ProcessReceipt callback must be set before the Players.PlayerAdded signal is fired, otherwise the player's -- existing receipts won't be processed when they join. MarketplaceService.ProcessReceipt = processReceipt Players.PlayerAdded:Connect(onPlayerAdded) Players.PlayerRemoving:Connect(onPlayerRemoving) for _, player in Players:GetPlayers() do onPlayerAdded(player) end ","keywords":""}]